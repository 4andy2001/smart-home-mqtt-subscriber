#! /usr/bin/env python

"""mqtt_subd.py

This module implements a sensor server that provides sensor data to connecting TCP clients.
At startup, it connects to an mqtt broker server and subscribes to various sensor topics.
Over the lifetime of the module, as sensor data is received from the mqtt broker server it
stores the most recent data.  When a TCP client connects to it, it sends the most recent data
to the client and then disconnects from the client.

Typically, this module would be executed at system startup.  E.g., on a Linux host, it could
be started by systemd.

At this date, the sensor data subscribed to is temperature, humidity and barometric pressure data,

Example:
    N/A

Attributes:
    N/A

Todo:
    N/A

.. _Google Python Style Guide:
   http://google.github.io/styleguide/pyguide.html

"""

from threading import Thread, Lock
import socket
import json
import syslog
import ssl

import paho.mqtt.client as mqtt
import time
import sys

import credentials


"""
For MQTT API see following websites:
https://github.com/eclipse/paho.mqtt.python
https://pypi.org/project/paho-mqtt/
https://mntolia.com/mqtt-python-with-paho-mqtt-client/

For documentation on test.mosquitto.org:
https://mosquitto.org/

"""

# Addresses and ports of various broker servers for testing and deployment
# broker_url = "mqtt.eclipse.org"
# broker_url = "test.mosquitto.org";
# broker_url = "rpi-homesrv"
# broker_port = 1883


broker_url = credentials.MQTT_URI
broker_port = credentials.MQTT_BROKER_PORT

client_id = "Subscriber-1"

# Host and port for the sensor server
host = '' # Any available
port = 12345


use_client_certificate = False  # Change to False to log in to MQTT broker using a client username/password.
ca_certificate_file = "/etc/ssl/certs/m2mqtt_ca.crt" # File that holds the CA certificate which signed the server certificate used by the broker and the client certificate used by this script.


# topic_mosquitto = "$SYS/#"

mutex = Lock()


def callback_on_connect(client, userdata, flags, rc):
    print("Connected With Result Code: {}".format(rc))

    # Subscribing in callback_on_connect means that if we lose the connection and
    # reconnect, then subscriptions will be renewed.
    # syslog.syslog("callback_on_connect(): calling subscribe_to_topics_and_set_callbacks")
    subscribe_to_topics_and_set_callbacks(client, topics_and_callbacks)


def callback_on_disconnect(client, userdata, rc):
    print("Disconnected With Result Code: {}".format(rc))

    
def callback_on_message(client, userdata, message):

    print(f"callback_on_message: {message.payload.decode()}")    
    # syslog.syslog("callback_on_message: " + message.payload.decode())
    pass


def callback_temperature_outside(client, userdata, message):
    """Callback invoked when data from the "/sensor/temperature/outside" is received

    When data from the "/sensor/temperature/outside" is received it replaces the
    existing temperature data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """

    # print("callback_temperature_outside: " + message.payload.decode())
    syslog.syslog("callback_temperature__outside: " + message.payload.decode())
    mutex.acquire()
    sensor_mailbox["temperature_outside"] = message.payload.decode()
    mutex.release()


def callback_pressure_outside(client, userdata, message):
    """Callback invoked when data from the "/sensor/pressure/outside" is received

    When data from the "/sensor/pressure/outside" is received it replaces the
    existing pressure data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """

    syslog.syslog("callback_pressure_outside: " + message.payload.decode())
    mutex.acquire()
    sensor_mailbox["pressure_outside"] = message.payload.decode()
    mutex.release()


def callback_humidity_outside(client, userdata, message):
    """Callback invoked when data from the "/sensor/humidity/outside" is received

    When data from the "/sensor/humidity/outside" is received it replaces the
    existing humidity data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """
    syslog.syslog("callback_humidity_outside: " + message.payload.decode())
    mutex.acquire()
    sensor_mailbox["humidity_outside"] = message.payload.decode()
    mutex.release()


def callback_time_outside(client, userdata, message):
    """Callback invoked when data from the "/sensor/time/outside is received

    When data from the "/sensor/time/outside" is received it replaces the
    existing time data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """

    print(f'callback_time_outside: {message.payload.decode()}')
    syslog.syslog("callback_time_outside: " + message.payload.decode())
    mutex.acquire()
    sensor_mailbox["time_outside"] = message.payload.decode()
    mutex.release()


def callback_will_outside(client, userdata, message):

    syslog.syslog("callback_will_outside: " + message.payload.decode())
    pass



def callback_temperature_hallway(client, userdata, message):
    """Callback invoked when data from the "/sensor/temperature/hallway" is received

    When data from the "/sensor/temperature/hallway" is received it replaces the
    existing temperature data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """

    syslog.syslog("callback_temperature_hallway: " + message.payload.decode())    
    # print("callback_temperature_hallway: " + message.payload.decode())

    mutex.acquire()
    sensor_mailbox["temperature_hallway"] = message.payload.decode()
    mutex.release()


def callback_pressure_hallway(client, userdata, message):
    """Callback invoked when data from the "/sensor/pressure/hallway" is received

    When data from the "/sensor/pressure/hallway" is received it replaces the
    existing pressure data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """

    syslog.syslog("callback_pressure_hallway: " + message.payload.decode())

    mutex.acquire()
    sensor_mailbox["pressure_hallway"] = message.payload.decode()
    mutex.release()


def callback_humidity_hallway(client, userdata, message):
    """Callback invoked when data from the "/sensor/humidity/hallway" is received

    When data from the "/sensor/humidity/hallway" is received it replaces the
    existing humidity data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """

    syslog.syslog("callback_humidity_hallway: " + message.payload.decode())
    mutex.acquire()
    sensor_mailbox["humidity_hallway"] = message.payload.decode()
    mutex.release()


def callback_time_hallway(client, userdata, message):
    """Callback invoked when data from the "/sensor/time/hallway is received

    When data from the "/sensor/time/hallway" is received it replaces the
    existing time data in the sensor_mailbox.

    Args:
        client (TBD): TBD
        userdata (TBD): TBD
        message (TBD): TBD

    Returns:
        None

    """

    print(f'callback_time_hallway: {message.payload.decode()}')    
    syslog.syslog("callback_time_hallway: " + message.payload.decode())


    mutex.acquire()
    sensor_mailbox["time_hallway"] = message.payload.decode()
    mutex.release()


def callback_will_hallway(client, userdata, message):

    syslog.syslog("callback_will_hallway: " + message.payload.decode())
    pass
    
  

def callback_mosquitto(client, userdata, message):

    # syslog.syslog(f"{sys._getframe().f_code.co_name}: "+message.payload.decode() + ": {userdata}")
    # syslog.syslog("callback_mosquitto: " + message.payload.decode() + ": ", userdata)
    pass


topics_and_callbacks = [("/sensor/temperature/outside", callback_temperature_outside),
                        ("/sensor/humidity/outside", callback_humidity_outside),
                        ("/sensor/pressure/outside", callback_pressure_outside),
                        ("/sensor/time/outside", callback_time_outside),
                        ("/sensor/will/outside", callback_will_outside),
                        ("/sensor/temperature/hallway", callback_temperature_hallway),
                        ("/sensor/humidity/hallway", callback_humidity_hallway),
                        ("/sensor/pressure/hallway", callback_pressure_hallway),
                        ("/sensor/time/hallway", callback_time_hallway),
                        ("/sensor/will/hallway", callback_will_hallway),
                        ]


def subscribe_to_topics_and_set_callbacks(client, topics_callbacks):

    print("subscribe_to_topics_and_set_callbacks(): entered")
    for topic in topics_callbacks:
        if client.subscribe(topic[0], qos=1)[0] != mqtt.MQTT_ERR_SUCCESS:
            sys.exit(2)
        client.message_callback_add(topic[0], topic[1])
    # syslog.syslog("subscribe_to_topics_and_set_callbacks(): exiting")


# Initialize the sensor_mailbox dictionary        
sensor_mailbox = {
      "time_hallway": "Waiting",
      "temperature_hallway": "Waiting",
      "humidity_hallway": "Waiting",
      "pressure_hallway": "Waiting",
      "time_outside": "Waiting",
      "temperature_outside": "Waiting",
      "humidity_outside": "Waiting",
      "pressure_outside": "Waiting"
    
}


def do_authentication(mqtts_client):
    if use_client_certificate:
        '''
        # Connect to the MQTT broker using a client certificate
        mqtts_client.tls_set( ca_certs = ca_certificate_file, 
                              certfile = client_certificate_file,
                              keyfile = client_key_file,
                              keyfile_password=client_key_file_password,
                              tls_version=ssl.PROTOCOL_TLSv1_2)
        mqtts_client.tls_insecure_set(False)
        '''
    else:
        # Connect to the MQTT broker using a username/password
        mqtts_client.tls_set( ca_certs = ca_certificate_file, tls_version=ssl.PROTOCOL_TLSv1_2)
        mqtts_client.tls_insecure_set(False)
        # Specify the username and password
        syslog.syslog("do_authentication(): calling mqtss_client.username_pw_set()")
        mqtts_client.username_pw_set(credentials.MQTT_USERNAME, credentials.MQTT_PW)

        
def mqtt_client_sensor_thread():
    """ Mqtt client sensor thread that subscribes to sensor data from an mqtt broker

     This thread connects to an mqtt broker server and subscribes to sensor data topics.
     It sets up a callback function for each topic.  When a specific topic is received,
     it's corresponding callback will be invoked and that callback will save the data
     for that topic in the sensor_mailbox.  (See individual callback routines for details)

     Returns:
         Function never returns

     """

    syslog.syslog("************* entering mqtt_client_sensor_thread ******************")
    
    # client = mqtt.Client(client_id="Subscriber-3")
    client = mqtt.Client()
    client.on_connect = callback_on_connect
    # client.callback_on_message = callback_on_message
    client.on_disconnect = callback_on_disconnect

    syslog.syslog("mqtt_client_sensor_thread(): calling do_authentication()")
    do_authentication(client)
    print("mqtt_client_sensor_thread(): calling client.connect()")    
    syslog.syslog("mqtt_client_sensor_thread(): calling client.connect()")
    client.connect(broker_url, broker_port)

    # Blocking call that processes network traffic, dispatches callbacks, and handles
    # reconnecting.
    print("mqtt_client_sensor_thread(): calling client.loop_forever()")    
    client.loop_forever()
    print("************* Should never get here ************************");
    
    
def sensor_server_thread():
    """Sensor server thread that serves sensor data to connecting TCP clients

    When a TCP client connects to this server port, it is sent the most recent
    sensor data from the sensor_mailbox and then disconnected.

    Returns:
        Function never returns

    """
    
    print("sensor_server_thread: entering...")
    s = socket.socket()  # Create a socket object
    # TODOAJS define this somewhere else host = socket.gethostname()  # Get local machine name
    s.bind((host, port))  # Bind to the port
    # print("sensor_server_thread: returned from bind()")
    s.listen(5)  # Listen for client connections
    # print("sensor_server_thread: returned from listen()")
    
    while True:
        # print("sensor_server_thread(): calling accept()")        
        c, addr = s.accept()  # Establish connection with connecting client
        # print("sensor_server_thread(): Got connection")

        mutex.acquire()
        json_string = json.dumps(sensor_mailbox)
        mutex.release()

        # syslog_string = "json_string = " + json_string + " type(json_string) = " + str(type(json_string))
        # syslog.syslog(syslog_string)

        json_bytes = bytearray(json_string.encode())
        # syslog.syslog ("sensor_server_thread(): calling c.send()")
        c.send(json_bytes)  # Send data to the client
        # syslog.syslog ("sensor_server_thread(): calling c.close()")
        c.close()  # Close the connection


def start_mqtt_client_sensor_thread():
    syslog.syslog("start_mqtt_client_sensor_thread(): starting mqtt_client_sensor_thread")
    thread = Thread(target=mqtt_client_sensor_thread)
    thread.start()


def start_sensor_server_thread():
    syslog.syslog("start_sensor_server_thread(): starting sensor_server_thread")
    thread = Thread(target=sensor_server_thread)
    thread.start()

   
def main():
    print("mqtt_subd: main entered, sleeping for 15 seconds before starting threads")    
    syslog.syslog("mqtt_subd: main entered, sleeping for 15 seconds before starting threads")
    # TODOAJS why do I need this sleep-should I be waiting somehow using systemd?
    time.sleep(15)
    # syslog.syslog("mqtt_subd main() entered")
    start_sensor_server_thread()
    start_mqtt_client_sensor_thread()

   
if __name__ == "__main__":
    main()
